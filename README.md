# АиСД МГТУ ИУ8 Осень 2022 (Ejudge)

## Отказ от ответственности

**Все, что в этом репозитории - истина в последней инстанции?**
Нет! Считайте, что это просто полезные материалы: решения всех принятых задач, тесты к ним,
скрипт для автоматического тестирования.
Некоторые представленные здесь утверждения могут оказаться устаревшими.
Тесты к задачам в следующем году могут дополниться, а задачи - полностью поменяться.
Представленный в репозитории тестировщик - лишь самописный инструмент, позволяющий автоматизировать
локальное тестирование решения, **не имеющий никакого отношения
к тому грейдеру, что будет проверять ваши решения на сервере**

**То есть я могу просто залить на сервер эти задачи и всё?**
Нет. На сервере ваше отправленное решение прогоняется как на
грейдере, так и на антиплагиате. Антиплагиат ищет совпадения со всеми когда-либо
проверенными им работами (в том числе и с данными), а также теми, что можно найти в интернете
(скопировать реализацию структуры с Хабра/англоязычного ресурса не получится).
**Списывать убедительно не рекомендуется - ваше решение
будет дисквалифицировано - вы получите штраф по баллам,
а преподаватель может выписать вам дизреспект и не поставить баллов за модуль вовсе!**
Настоятельно рекомендую сделать эти задачи самостоятельно и
смотреть на решения только в случае, если у вас серьезные затруднения

## Вопросы

**Зачем я всё это выложил?**
Чтобы предупредить следующие поколения о странностях тестов, ~~которые ни один человек не предугадает,~~
а также, чтобы у вас в крайнем случае всегда было куда подсмотреть
(если вы неделю сидите и не можете понять, как делать задание)

**Серёга, твой код - просто ужас!**
Пожалуй, не идеальный. Есть то, что можно было улучшить, но в круговороте дедлайнов
это сделать так и не удалось. К тому же, все представленные решения были приняты преподавателями.
Да и у вас есть прекрасная возможность половить лулзов с моей автокоррекции ~~пока не начнете писать её сами~~

**Почему почти все задачи написаны на Python?**
Потому что ~~я умею писать только на псевдокоде~~ он достаточно быстрый и хорошо
подходит для решения поставленных перед нами задач. Там, где необходимо работать с памятью
(Дек), хорошо подойдет C++. В остальных задачах это не требуется. Плюсовый код на Ejudge
(далее - ёж) тестируется под дикими санитайзерами (инструменты, отслеживающие утечки памяти),
что катастрофически его замедляет (не забываем, что решение должно проходить тесты как по памяти,
так и по времени). Сдать все таски на тех же плюсах (или хаскеле) можно. А нужно ли? Время не резиновое.
Курс даётся не для того, чтобы научить тонкостям программирования (предполагается, что прогать все +- умеют).
Его цели - закрепить пройденный на занятиях материал, научить ~~вычислять сумму чисел~~
эффективно решать прикладные задачи, определять сложности алгоритмов, оптимизировать их
и находить баланс между скоростью и памятью, а также обосновывать свой выбор

## Инкапсуляция

В большинстве задач 2 и 3 модуля при реализации СД требуется её инкапсулировать.
Кто-то может не обратить внимание на это требование, что будет большой
ошибкой, которая может стоить вам баллов.

**Что означает инкапсулировать СД?** Реализовать её таким образом, чтобы
среднестатистический пользователь мог подключить её к своему проекту
(как вы подключаете тот же set в C++) и не иметь проблем по типу:

- **методы структуры что-то печатают**

  Оформление вывода осуществляется в мейне. Все взаимодействия с СД
  происходят посредством вызова его методов (в Python, вроде как, допускается
  чтение полей, но всегда лучше написать какой-нибудь геттер)

- **методы структуры возвращают чрезмерное количество значений**

  Возврат "заточенных" под требуемый в конкретной задаче формат вывода значений -
  нарушение инкапсуляции.
  > Пример. Метод max() у min-кучи, который возвращает (key, index, value) - явно
  > написан с оглядкой на условие задачи.

Сначала подумайте, какие у СД должны быть методы и
какие у них должны быть сигнатуры, а только затем смотрите, в каком
формате вам необходимо реализовать вывод в мейне. **Вашей СД и всему,
что внутри неё находится, должно быть фиолетово, что и в каком
формате от вас требуют в выводе на еже**

## Задачи

* **Модуль 1**
    * [Сумма (Python)](module-1/a-sum.py)
    * [Дек (C++)](module-1/b-dequeue.cpp)
    * [Зависимости (Python)](module-1/c-dependencies.py)

* **Модуль 2**
    * [Splay-дерево (Python)](module-2/b-splay-tree.py)
    * [Min-куча (Python)](module-2/c-min-heap.py)
    * [Автокоррекция (Python)](module-2/d-autocorrection.py)

* **Модуль 3**
    * Блок (Python)
    * Фильтр Блума (Python)
    * Рюкзак (Python)

## Тестирование для решений на Python

**Все доступные нам тесты (были также и те,
ввод которых был не доступен) 2022 года лежат в папке tests**

Для тестирования своих решений можно использовать `check.sh` из папки `scripts`.
Для этого скопируйте файлы `checker.py` и `check.sh` в одну директорию и введите команду
`./check.sh <solution.py> <tests-folder> <tests-number>`, где

- `<solution.py>` - название вашего скрипта на Python
  (или путь до него относительно `check.sh`, если скопированные файлы находятся в другой директории)
- `<tests-folder>` - путь до папки с тестами к вашему заданию.
  В этой папке должны находится папки `dat` и `ans` с вводом тестов
  и ответами к ним соответственно (см. пример в репозитории)
- `<tests-number>` - количество тестов. Будут прогоняться все тесты в диапазоне `[0;N]`
  (от `1.dat` до `N.dat`). Ничего страшного,
  если некоторых тестов из диапазона не будет, — они будут проигнорированы

![Screenshot](assets/checker-sample.png)

**P.S.:** Суть представленного проверяющего
скрипта - **построчно сверить правильный вывод** (один из правильных?) с **выводом решения пользователя**.
Это важно понимать. К примеру, даже при полностью корректном выполнении
**тесты к задаче C из 1 модуля не будут проходить практически всегда**,
так как по условию порядок вывода зависимостей не важен. Грейдер на сервере это учитывает и
просто следит за тем, что бы все нужные зависимости присутствовали и никаких других не было.
Также, судя по всему (?), сервер может принять как ответ с символом новой строки `'\n'` в
последней строке, так и без него (не на всех задачах (помнится, эта проблема была в 1 модуле).
Сделано это для того, чтобы выбор языка меньше влиял на решение сервера).
Практически все тесты в репозитории "адаптированы" под вывод Python (где print совершает перевод строку) -
все (с парой исключений) представленные задачи успешно проходят локальное тестирование
на предоставленных тестах в том виде, в котором они были загружены на ежа и одобрены судьями

**Если возникают любые вопросы касательно условия задачи и формата вывода - всегда лучше
спросить преподавателя**

**Если вылезает ошибка количества строк при локальном тестировании - попробуйте добавить/убрать
пустую строку в конце файла `.ans` и попробовать запустить проверку заново**

## Система оценивания

На осень 2022 года актуальны следующие правила оценивания модулей на еже:

- За модуль можно получить **максимум 20 баллов**
- За полностью сданный и принятый преподавателем модуль можно получить **минимум 5 баллов**
- За **каждый реждект** (отклонение) работы вы теряете **2 балла**
- За сдачу модуля **после обозначенного дедлайна** вы теряете **5 баллов** (просроченный модуль - если хоть 1 задача не сдана к моменту основного
  ревью)
- Если вы потратили на задачу **от 4 до 7 попыток** включительно, вы теряете **2 балла**
- Если вы потратили на задачу **8 и более попыток**, вы теряете **4 балла**
- За **списывание** задачи вы теряете **3 балла**
- За **повторное списывание** баллы за модуль **начислены не будут** (даже если потом вы его полностью сделаете сами от и до)
- Если вы захотели зарефакторить своё решение и отправить повторно посылку при статусе **Ожидает проверки**:
    * и ваш код **прошел все тесты** - счетчик попыток **не увеличится**, а предыдующее пройденное решение будет **проигнорировано** - проверяться
      будет всегда крайнее решение, которое прошло все тесты
    * а ваш код **упал на тестах** - задание останется сданным по прошлой посылке, но **счётчик попыток увеличится**, что при некоторых значениях
      может сказаться на ваших баллах за модуль

```
       Автор: Сергей Лагов
Внесли вклад: Андрей Николаев
              Иван Алферов
              Богдан Шумилишский
```